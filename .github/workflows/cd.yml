name: CD - Deploy

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-1
      
      # SNS Topic
      SNS_TOPIC_NAME: fcg-payment-events
      
      # SQS Queue
      SQS_QUEUE_NAME: fcg-payment-events-queue
      
      # Lambda
      LAMBDA_FUNCTION_NAME: fcg-payments-processor
      LAMBDA_HANDLER: PaymentsProcessor.Function::PaymentsProcessor.Function.Function::FunctionHandler
      
      # ECS
      ECS_CLUSTER: fcg-cluster
      ECS_SERVICE: fcg-payments-task-service-rfv89au5

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Instalar SDK do .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build project
        run: dotnet build --no-restore --configuration Release

      - name: Run tests
        run: dotnet test --configuration Release --no-build --verbosity normal

      - name: Docker Login
        uses: docker/login-action@v3.6.0
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build image (local)
        uses: docker/build-push-action@v6.18.0
        with:
          context: .
          push: false
          load: true
          tags: ${{ secrets.DOCKER_USERNAME }}/tech-challenge-payments-alpine:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Scan image with Trivy
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ secrets.DOCKER_USERNAME }}/tech-challenge-payments-alpine:latest
          format: table
          exit-code: 1
          severity: CRITICAL
          ignore-unfixed: true

      - name: Push image
        run: docker push ${{ secrets.DOCKER_USERNAME }}/tech-challenge-payments-alpine:latest

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Install tools (Lambda + jq)
        run: |
          dotnet tool install -g Amazon.Lambda.Tools
          echo "/home/runner/.dotnet/tools" >> $GITHUB_PATH
          sudo apt-get update
          sudo apt-get install -y jq
          
      - name: Ensure SNS Topic
        id: sns
        run: |
          set -euo pipefail
          
          TOPIC_ARN=$(aws sns list-topics --query "Topics[?contains(TopicArn, '$SNS_TOPIC_NAME')].TopicArn" --output text 2>/dev/null || true)
          
          if [ -z "${TOPIC_ARN:-}" ] || [ "${TOPIC_ARN:-}" = "None" ]; then
            echo "Creating SNS topic: $SNS_TOPIC_NAME"
            TOPIC_ARN=$(aws sns create-topic \
              --name "$SNS_TOPIC_NAME" \
              --query 'TopicArn' \
              --output text)
            echo "Topic created: $TOPIC_ARN"
          else
            echo "Topic already exists: $TOPIC_ARN"
          fi

          echo "TOPIC_ARN=$TOPIC_ARN" >> $GITHUB_OUTPUT

      - name: Ensure SQS Queue
        id: sqs
        run: |
          set -euo pipefail
          
          QUEUE_URL=$(aws sqs get-queue-url --queue-name "$SQS_QUEUE_NAME" --query 'QueueUrl' --output text 2>/dev/null || true)
          
          if [ -z "${QUEUE_URL:-}" ] || [ "${QUEUE_URL:-}" = "None" ]; then
            echo "Creating SQS queue: $SQS_QUEUE_NAME"
            QUEUE_URL=$(aws sqs create-queue \
              --queue-name "$SQS_QUEUE_NAME" \
              --attributes "ReceiveMessageWaitTimeSeconds=20,VisibilityTimeout=300" \
              --query 'QueueUrl' \
              --output text)
            echo "Queue created: $QUEUE_URL"
          else
            echo "Queue already exists: $QUEUE_URL"
            aws sqs set-queue-attributes \
              --queue-url "$QUEUE_URL" \
              --attributes "ReceiveMessageWaitTimeSeconds=20,VisibilityTimeout=300" \
              >/dev/null
          fi
          
          QUEUE_ARN=$(aws sqs get-queue-attributes \
            --queue-url "$QUEUE_URL" \
            --attribute-names QueueArn \
            --query 'Attributes.QueueArn' \
            --output text)

          echo "QUEUE_URL=$QUEUE_URL" >> $GITHUB_OUTPUT
          echo "QUEUE_ARN=$QUEUE_ARN" >> $GITHUB_OUTPUT

      - name: Configure SQS Queue Policy (allow SNS to send messages)
        env:
          TOPIC_ARN: ${{ steps.sns.outputs.TOPIC_ARN }}
          QUEUE_URL: ${{ steps.sqs.outputs.QUEUE_URL }}
          QUEUE_ARN: ${{ steps.sqs.outputs.QUEUE_ARN }}
        run: |
          set -euo pipefail

          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          
          POLICY=$(jq -nc \
            --arg qarn "$QUEUE_ARN" \
            --arg tarn "$TOPIC_ARN" \
            --arg acc "$ACCOUNT_ID" '{
            Version:"2012-10-17",
            Statement:[
              {
                Sid:"AllowSNSToSendMessage",
                Effect:"Allow",
                Principal:{"Service":"sns.amazonaws.com"},
                Action:["sqs:SendMessage"],
                Resource:$qarn,
                Condition:{ 
                  ArnEquals:{ "aws:SourceArn": $tarn }
                }
              },
              {
                Sid:"AllowAccountAccess",
                Effect:"Allow",
                Principal:"*",
                Action:["sqs:SendMessage"],
                Resource:$qarn,
                Condition:{ 
                  StringEquals:{ "aws:PrincipalAccount": $acc }
                }
              }
            ]
          }')
          
          ATTR_FILE=$(mktemp)
          jq -nc --arg policy "$POLICY" '{Policy: $policy}' > "$ATTR_FILE"
          
          aws sqs set-queue-attributes \
            --queue-url "$QUEUE_URL" \
            --attributes "file://$ATTR_FILE" \
            >/dev/null

          echo "SQS policy configured to accept messages from SNS"

      - name: Subscribe SQS to SNS Topic
        env:
          TOPIC_ARN: ${{ steps.sns.outputs.TOPIC_ARN }}
          QUEUE_ARN: ${{ steps.sqs.outputs.QUEUE_ARN }}
        run: |
          set -euo pipefail

          # Verifica se a subscription já existe
          SUBSCRIPTION_ARN=$(aws sns list-subscriptions-by-topic \
            --topic-arn "$TOPIC_ARN" \
            --query "Subscriptions[?Endpoint=='$QUEUE_ARN'].SubscriptionArn" \
            --output text 2>/dev/null || true)

          if [ -z "${SUBSCRIPTION_ARN:-}" ] || [ "${SUBSCRIPTION_ARN:-}" = "None" ]; then
            echo "Creating SNS subscription: Topic -> SQS"
            aws sns subscribe \
              --topic-arn "$TOPIC_ARN" \
              --protocol sqs \
              --notification-endpoint "$QUEUE_ARN" \
              >/dev/null
            echo "Subscription created"
          else
            echo "Subscription already exists: $SUBSCRIPTION_ARN"
          fi
          
      - name: Package Lambda (.NET)
        run: |
          set -euo pipefail
          cd serverless/PaymentsProcessor.Function/src/PaymentsProcessor.Function
          dotnet lambda package -c Release -o "$GITHUB_WORKSPACE/payments-processor.zip"
          ls -lah "$GITHUB_WORKSPACE/payments-processor.zip"

      - name: Create or Update Lambda
        env:
          CONN_STR: ${{ secrets.PAYMENTS_CONNECTION_STRING }}
        run: |
          set -euo pipefail
          ZIP="$GITHUB_WORKSPACE/payments-processor.zip"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          DYNAMIC_ROLE_ARN="arn:aws:iam::$ACCOUNT_ID:role/LabRole"
          
          echo "Using Role ARN: $DYNAMIC_ROLE_ARN"

          if aws lambda get-function --function-name "$LAMBDA_FUNCTION_NAME" >/dev/null 2>&1; then
            echo "Updating Lambda code: $LAMBDA_FUNCTION_NAME"
            aws lambda update-function-code \
              --function-name "$LAMBDA_FUNCTION_NAME" \
              --zip-file "fileb://$ZIP" \
              >/dev/null

            aws lambda wait function-updated --function-name "$LAMBDA_FUNCTION_NAME"

            echo "Updating Lambda config"
            aws lambda update-function-configuration \
              --function-name "$LAMBDA_FUNCTION_NAME" \
              --handler "$LAMBDA_HANDLER" \
              --timeout 300 \
              --memory-size 512 \
              --role "$DYNAMIC_ROLE_ARN" \
              --environment "Variables={ConnectionStrings__DefaultConnection='$CONN_STR'}" \
              >/dev/null

            aws lambda wait function-updated --function-name "$LAMBDA_FUNCTION_NAME"
          else
            echo "Creating Lambda: $LAMBDA_FUNCTION_NAME"
            aws lambda create-function \
              --function-name "$LAMBDA_FUNCTION_NAME" \
              --runtime dotnet8 \
              --handler "$LAMBDA_HANDLER" \
              --role "$DYNAMIC_ROLE_ARN" \
              --zip-file "fileb://$ZIP" \
              --timeout 300 \
              --memory-size 512 \
              --environment "Variables={ConnectionStrings__DefaultConnection='$CONN_STR'}" \
              --publish \
              >/dev/null
          fi

      - name: Ensure SQS -> Lambda trigger (Event Source Mapping)
        env:
          QUEUE_ARN: ${{ steps.sqs.outputs.QUEUE_ARN }}
        run: |
          set -euo pipefail

          UUID=$(aws lambda list-event-source-mappings \
            --function-name "$LAMBDA_FUNCTION_NAME" \
            --event-source-arn "$QUEUE_ARN" \
            --query 'EventSourceMappings[0].UUID' \
            --output text)

          if [ -z "${UUID:-}" ] || [ "$UUID" = "None" ]; then
            echo "Creating event source mapping SQS -> Lambda"
            aws lambda create-event-source-mapping \
              --function-name "$LAMBDA_FUNCTION_NAME" \
              --event-source-arn "$QUEUE_ARN" \
              --batch-size 10 \
              --enabled \
              >/dev/null
            echo "Event source mapping created"
          else
            echo "Event source mapping already exists: $UUID"
          fi
          
      - name: Update ECS task definition (add SNS Topic ARN) and deploy
        env:
          TOPIC_ARN: ${{ steps.sns.outputs.TOPIC_ARN }}
        run: |
          set -euo pipefail

          TD_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --query 'services[0].taskDefinition' \
            --output text)

          echo "Current task definition: $TD_ARN"

          TD_JSON=$(aws ecs describe-task-definition \
            --task-definition "$TD_ARN" \
            --query 'taskDefinition')
            
          NEW_TD=$(echo "$TD_JSON" | jq \
            --arg topic "$TOPIC_ARN" \
            --arg region "$AWS_REGION" '
            del(
              .taskDefinitionArn,
              .revision,
              .status,
              .requiresAttributes,
              .compatibilities,
              .registeredAt,
              .registeredBy
            )
            | .containerDefinitions[0].environment =
                (
                  (.containerDefinitions[0].environment // [])
                  | map(select(.name != "AWS__SNS__PaymentEventsTopicArn" and .name != "AWS__Region"))
                  + [
                      {"name": "AWS__SNS__PaymentEventsTopicArn", "value": $topic},
                      {"name": "AWS__Region", "value": $region}
                    ]
                )
          ')

          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TD" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "New task definition: $NEW_TD_ARN"

          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_SERVICE" \
            --task-definition "$NEW_TD_ARN" \
            --force-new-deployment \
            --region "$AWS_REGION" \
            >/dev/null

          echo "ECS service updated with new task definition"

      - name: Force ECS redeploy (pull latest image)
        run: |
          aws ecs update-service \
            --cluster "$ECS_CLUSTER" \
            --service "$ECS_SERVICE" \
            --force-new-deployment \
            --region "$AWS_REGION"
          
          echo "Deployment complete!"
          echo "SNS Topic: ${{ steps.sns.outputs.TOPIC_ARN }}"
          echo "SQS Queue: ${{ steps.sqs.outputs.QUEUE_URL }}"
          echo "Lambda: $LAMBDA_FUNCTION_NAME"